<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/backend/app/migrate_used_storage.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/backend/app/migrate_used_storage.py" />
              <option name="updatedContent" value="&quot;&quot;&quot;&#10;Migration script to change used_storage_mb column type from INTEGER to FLOAT&#10;Run this script to migrate existing data.&#10;&quot;&quot;&quot;&#10;import asyncio&#10;from sqlalchemy.ext.asyncio import create_async_engine&#10;from sqlalchemy import text&#10;from core.config import settings&#10;&#10;&#10;async def migrate_used_storage_to_float():&#10;    engine = create_async_engine(settings.DB_URL, echo=True)&#10;    &#10;    print(&quot;Starting migration: changing used_storage_mb from INTEGER to FLOAT...&quot;)&#10;    &#10;    try:&#10;        async with engine.begin() as conn:&#10;            # PostgreSQL: ALTER COLUMN type&#10;            await conn.execute(text(&#10;                &quot;ALTER TABLE users ALTER COLUMN used_storage_mb TYPE REAL USING used_storage_mb::REAL&quot;&#10;            ))&#10;            &#10;        print(&quot;Migration completed successfully!&quot;)&#10;        print(&quot;Column 'used_storage_mb' is now of type FLOAT.&quot;)&#10;        &#10;    except Exception as e:&#10;        print(f&quot;Migration failed: {str(e)}&quot;)&#10;        print(&quot;\nIf the column is already FLOAT, you can ignore this error.&quot;)&#10;        &#10;    finally:&#10;        await engine.dispose()&#10;&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    asyncio.run(migrate_used_storage_to_float())&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/backend/app/test_main.http">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/backend/app/test_main.http" />
              <option name="originalContent" value="# Test your FastAPI endpoints&#10;&#10;GET http://127.0.0.1:8000/&#10;Accept: application/json&#10;&#10;###&#10;&#10;GET http://127.0.0.1:8000/hello/User&#10;Accept: application/json&#10;&#10;###&#10;" />
              <option name="updatedContent" value="# Test your FastAPI endpoints&#10;&#10;GET http://127.0.0.1:8000/&#10;Accept: application/json&#10;&#10;###&#10;&#10;GET http://127.0.0.1:8000/hello/User&#10;Accept: application/json&#10;&#10;###&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/docker-compose.dev.yml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/docker-compose.dev.yml" />
              <option name="originalContent" value="# Dockerfile dla środowiska deweloperskiego z hot-reload&#10;&#10;FROM node:22-alpine&#10;&#10;WORKDIR /app&#10;&#10;# Instalacja zależności&#10;COPY package.json package-lock.json* ./&#10;RUN npm ci --prefer-offline --no-audit&#10;&#10;# Kopiowanie plików źródłowych&#10;COPY . .&#10;&#10;# Expose portu&#10;EXPOSE 5173&#10;&#10;# Zmienne środowiskowe dla dev&#10;ENV NODE_ENV=development&#10;&#10;# Uruchomienie w trybie dev z hot-reload&#10;CMD [&quot;npm&quot;, &quot;run&quot;, &quot;dev&quot;, &quot;--&quot;, &quot;--host&quot;, &quot;0.0.0.0&quot;]&#10;&#10;" />
              <option name="updatedContent" value="# Docker Compose dla środowiska deweloperskiego&#10;&#10;services:&#10;  frontend:&#10;    build:&#10;      context: ./frontend&#10;      dockerfile: Dockerfile.dev&#10;    container_name: spcloud_frontend_dev&#10;    restart: unless-stopped&#10;    ports:&#10;      - &quot;${FRONTEND_PORT:-5173}:5173&quot;&#10;    volumes:&#10;      - ./frontend:/app&#10;      - /app/node_modules&#10;    environment:&#10;      - NODE_ENV=development&#10;      - PUBLIC_API_URL=${PUBLIC_API_URL:-http://localhost:8000}&#10;    depends_on:&#10;      - backend&#10;    networks:&#10;      - spcloud_network&#10;&#10;  backend:&#10;    build:&#10;      context: ./backend&#10;    container_name: fastapi_backend&#10;    restart: unless-stopped&#10;    env_file: .env&#10;    ports:&#10;      - &quot;8000:8000&quot;&#10;    volumes:&#10;      - ./backend/app:/app&#10;    depends_on:&#10;      - db&#10;      - minio&#10;    networks:&#10;      - spcloud_network&#10;&#10;  minio:&#10;    image: minio/minio:latest&#10;    container_name: minio&#10;    command: server /data --console-address &quot;:9001&quot;&#10;    restart: unless-stopped&#10;    environment:&#10;      MINIO_ROOT_USER: admin&#10;      MINIO_ROOT_PASSWORD: supersecret&#10;    ports:&#10;      - &quot;9000:9000&quot;&#10;      - &quot;9001:9001&quot;&#10;    volumes:&#10;      - minio_data:/data&#10;    networks:&#10;      - spcloud_network&#10;&#10;  db:&#10;    image: postgres:18&#10;    container_name: postgres_db&#10;    restart: unless-stopped&#10;    env_file: .env&#10;    ports:&#10;      - &quot;${POSTGRES_PORT:-5432}:5432&quot;&#10;    volumes:&#10;      - db_data:/var/lib/postgresql/data&#10;    networks:&#10;      - spcloud_network&#10;&#10;volumes:&#10;  db_data:&#10;  minio_data:&#10;&#10;networks:&#10;  spcloud_network:&#10;    driver: bridge" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/docs/STORAGE_FIX.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/docs/STORAGE_FIX.md" />
              <option name="updatedContent" value="# Poprawki wartości w endpoincie /api/v1/files/me&#10;&#10;## Problem&#10;Wartości w odpowiedzi endpointu były niespójne:&#10;```json&#10;{&#10;  &quot;total_size_bytes&quot;: 23125511,&#10;  &quot;total_size_mb&quot;: 22.05,&#10;  &quot;used_storage_mb&quot;: 21.0,        // ❌ Niezgodne!&#10;  &quot;total_versions_size_bytes&quot;: 23125511,&#10;  &quot;total_versions_size_mb&quot;: 22.05&#10;}&#10;```&#10;&#10;## Przyczyny problemu&#10;1. **Typ kolumny**: `used_storage_mb` w tabeli `users` był typu `INTEGER`, co powodowało utratę precyzji przy zaokrągleniu&#10;2. **Źródło danych**: Wartość była pobierana z kolumny w bazie danych, która mogła być nieaktualna&#10;3. **Brak spójności**: Wartość `used_storage_mb` mogła się różnić od rzeczywistej sumy rozmiarów wszystkich wersji&#10;&#10;## Zaimplementowane poprawki&#10;&#10;### 1. Zmiana typu kolumny w modelu&#10;**Plik**: `backend/app/models/models.py`&#10;&#10;```python&#10;# Przed:&#10;used_storage_mb = Column(Integer, default=0)&#10;&#10;# Po:&#10;used_storage_mb = Column(Float, default=0.0)&#10;```&#10;&#10;### 2. Obliczanie rzeczywistego wykorzystania miejsca&#10;**Plik**: `backend/app/services/file_service.py`&#10;&#10;Metoda `get_user_storage_info()` teraz:&#10;- Pobiera wszystkie wersje plików z bazy danych&#10;- Sumuje ich rozmiary&#10;- Oblicza rzeczywiste wykorzystanie miejsca na podstawie sumy&#10;&#10;```python&#10;# Rzeczywiste wykorzystane miejsce to suma wszystkich wersji&#10;actual_used_storage_mb = total_versions_size_bytes / (1024 * 1024)&#10;&#10;return {&#10;    &quot;used_storage_mb&quot;: round(actual_used_storage_mb, 2),&#10;    # ...&#10;}&#10;```&#10;&#10;## Jak zastosować poprawki&#10;&#10;### Krok 1: Aktualizacja kodu ✅&#10;Kod został już zaktualizowany&#10;&#10;### Krok 2: Restart z czystą bazą danych&#10;```bash&#10;# Zatrzymaj kontenery&#10;docker-compose down&#10;&#10;# Usuń volume bazy danych&#10;docker volume rm spcloud_postgres_data&#10;# lub znajdź nazwę volume:&#10;docker volume ls&#10;&#10;# Uruchom ponownie - baza zostanie stworzona z nowymi typami&#10;docker-compose up -d&#10;```&#10;&#10;**⚠️ UWAGA:** To usunie wszystkie dane z bazy! Zrób backup jeśli potrzebujesz danych.&#10;&#10;**Dlaczego nie potrzebujemy migracji?**&#10;Projekt używa `Base.metadata.create_all()` w `init_db.py`, więc wystarczy usunąć volume i baza zostanie stworzona od nowa z poprawnymi typami kolumn.&#10;&#10;### Krok 3: Przetestuj&#10;```bash&#10;curl -X GET &quot;http://localhost:8000/api/v1/files/me&quot; \&#10;  -H &quot;Authorization: Bearer YOUR_TOKEN&quot;&#10;```&#10;&#10;## Rezultat&#10;&#10;Po zastosowaniu poprawek, wartości będą spójne:&#10;&#10;```json&#10;{&#10;  &quot;username&quot;: &quot;test&quot;,&#10;  &quot;total_files&quot;: 3,&#10;  &quot;total_size_bytes&quot;: 23125511,&#10;  &quot;total_size_mb&quot;: 22.05,&#10;  &quot;max_storage_mb&quot;: 100,&#10;  &quot;used_storage_mb&quot;: 22.05,              // ✅ Zgodne!&#10;  &quot;available_storage_mb&quot;: 77.95,&#10;  &quot;storage_usage_percentage&quot;: 22.05,&#10;  &quot;total_favorite_files&quot;: 0,&#10;  &quot;total_versions&quot;: 3,&#10;  &quot;total_versions_size_bytes&quot;: 23125511,&#10;  &quot;total_versions_size_mb&quot;: 22.05        // ✅ Zgodne!&#10;}&#10;```&#10;&#10;## Dodatkowe korzyści&#10;&#10;1. **Precyzja**: Wartości Float pozwalają na dokładniejsze śledzenie wykorzystania miejsca&#10;2. **Spójność**: `used_storage_mb` zawsze równa się `total_versions_size_mb`&#10;3. **Niezawodność**: Wartość jest obliczana dynamicznie na podstawie rzeczywistych danych w bazie&#10;4. **Łatwiejsze debugowanie**: Łatwiej zauważyć niespójności, gdy wartości są identyczne&#10;5. **Prostota**: Nie potrzebujemy skryptów migracji - wystarczy restart z czystą bazą&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/docs/STORAGE_INFO_ENDPOINT.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/docs/STORAGE_INFO_ENDPOINT.md" />
              <option name="updatedContent" value="# Endpoint informacji o miejscu przechowywania&#10;&#10;## GET /api/v1/files/me&#10;&#10;Endpoint zwracający szczegółowe informacje o przechowywaniu plików dla zalogowanego użytkownika.&#10;&#10;### Wymagania&#10;- Użytkownik musi być zalogowany (wymagany token JWT)&#10;&#10;### Odpowiedź&#10;&#10;```json&#10;{&#10;  &quot;username&quot;: &quot;test1&quot;,&#10;  &quot;total_files&quot;: 4,&#10;  &quot;total_size_bytes&quot;: 13267989,&#10;  &quot;total_size_mb&quot;: 12.65,&#10;  &quot;max_storage_mb&quot;: 100,&#10;  &quot;used_storage_mb&quot;: 12.65,&#10;  &quot;available_storage_mb&quot;: 87.35,&#10;  &quot;storage_usage_percentage&quot;: 12.65,&#10;  &quot;total_favorite_files&quot;: 0,&#10;  &quot;total_versions&quot;: 4,&#10;  &quot;total_versions_size_bytes&quot;: 13267989,&#10;  &quot;total_versions_size_mb&quot;: 12.65&#10;}&#10;```&#10;&#10;### Pola odpowiedzi&#10;&#10;| Pole | Typ | Opis |&#10;|------|-----|------|&#10;| `username` | string | Nazwa użytkownika |&#10;| `total_files` | integer | Całkowita liczba plików użytkownika (aktualne wersje) |&#10;| `total_size_bytes` | integer | Całkowity rozmiar wszystkich plików w bajtach |&#10;| `total_size_mb` | float | Całkowity rozmiar wszystkich plików w MiB |&#10;| `max_storage_mb` | integer | Maksymalny limit przechowywania w MiB |&#10;| `used_storage_mb` | float | Wykorzystane miejsce w MiB (wszystkie wersje) |&#10;| `available_storage_mb` | float | Dostępne miejsce w MiB |&#10;| `storage_usage_percentage` | float | Procent wykorzystania miejsca |&#10;| `total_favorite_files` | integer | Liczba plików oznaczonych jako ulubione |&#10;| `total_versions` | integer | Całkowita liczba wszystkich wersji plików |&#10;| `total_versions_size_bytes` | integer | Całkowity rozmiar wszystkich wersji w bajtach |&#10;| `total_versions_size_mb` | float | Całkowity rozmiar wszystkich wersji w MiB |&#10;&#10;### Jednostki - MiB vs MB&#10;&#10;**⚠️ WAŻNE:** Wszystkie pola z sufiksem `_mb` używają **MiB (mebibajtów)**, nie MB (megabajtów)!&#10;&#10;- **1 MiB = 1024² = 1,048,576 bajtów** ← używamy tego&#10;- **1 MB = 1000² = 1,000,000 bajtów** ← SI standard&#10;&#10;**Dlaczego MiB?**&#10;- Standard w systemach plików (Linux, Windows, macOS)&#10;- Standard w cloud storage i przechowywaniu danych&#10;- Większa precyzja dla binarnych operacji&#10;&#10;**Przykład konwersji:**&#10;```&#10;13,267,989 bajtów / 1,048,576 = 12.65 MiB&#10;13,267,989 bajtów / 1,000,000 = 13.27 MB&#10;```&#10;&#10;### Przykładowe użycie&#10;&#10;#### cURL&#10;```bash&#10;curl -X GET &quot;http://localhost:8000/api/v1/files/me&quot; \&#10;  -H &quot;Authorization: Bearer YOUR_JWT_TOKEN&quot; \&#10;  -H &quot;Accept: application/json&quot;&#10;```&#10;&#10;#### Python&#10;```python&#10;import requests&#10;&#10;url = &quot;http://localhost:8000/api/v1/files/me&quot;&#10;headers = {&#10;    &quot;Authorization&quot;: &quot;Bearer YOUR_JWT_TOKEN&quot;,&#10;    &quot;Accept&quot;: &quot;application/json&quot;&#10;}&#10;&#10;response = requests.get(url, headers=headers)&#10;data = response.json()&#10;&#10;print(f&quot;Użytkownik: {data['username']}&quot;)&#10;print(f&quot;Liczba plików: {data['total_files']}&quot;)&#10;print(f&quot;Wykorzystane miejsce: {data['used_storage_mb']} MiB / {data['max_storage_mb']} MiB&quot;)&#10;print(f&quot;Procent wykorzystania: {data['storage_usage_percentage']}%&quot;)&#10;&#10;# Konwersja na MB (jeśli potrzebna)&#10;used_mb_si = data['total_size_bytes'] / 1_000_000&#10;print(f&quot;Wykorzystane miejsce (SI): {used_mb_si:.2f} MB&quot;)&#10;```&#10;&#10;#### JavaScript/TypeScript&#10;```typescript&#10;const response = await fetch('http://localhost:8000/api/v1/files/me', {&#10;  method: 'GET',&#10;  headers: {&#10;    'Authorization': `Bearer ${token}`,&#10;    'Accept': 'application/json'&#10;  }&#10;});&#10;&#10;const data = await response.json();&#10;console.log('Storage Info:', data);&#10;&#10;// Konwersja na MB (jeśli potrzebna)&#10;const usedMB = data.total_size_bytes / 1_000_000;&#10;console.log(`Used storage: ${usedMB.toFixed(2)} MB`);&#10;```&#10;&#10;### Kody statusu&#10;&#10;| Kod | Opis |&#10;|-----|------|&#10;| 200 | Sukces - zwrócono informacje o przechowywaniu |&#10;| 401 | Unauthorized - brak tokena lub nieprawidłowy token |&#10;| 404 | Not Found - użytkownik nie znaleziony |&#10;| 500 | Internal Server Error - błąd serwera |&#10;&#10;### Uwagi&#10;&#10;#### Synchronizacja danych&#10;- Endpoint oblicza rzeczywiste wykorzystanie miejsca na podstawie wszystkich wersji w bazie danych&#10;- Automatycznie synchronizuje wartość `used_storage_mb` w tabeli użytkownika z rzeczywistą&#10;- Jeśli wykryje różnicę &gt; 0.01 MiB, zaktualizuje wartość w bazie&#10;- Wartości są zawsze spójne: `used_storage_mb` = `total_versions_size_mb`&#10;&#10;#### Dane&#10;- `total_size_bytes` - rozmiar tylko aktualnych wersji plików&#10;- `total_versions_size_bytes` - rozmiar wszystkich wersji (aktualne + historyczne)&#10;- `used_storage_mb` - identyczne z `total_versions_size_mb` (bo wszystkie wersje są w S3)&#10;- Wszystkie wartości w MiB są zaokrąglone do 2 miejsc po przecinku&#10;&#10;#### Wersjonowanie&#10;- System przechowuje wszystkie wersje plików w S3&#10;- Każda wersja zajmuje miejsce w limicie użytkownika&#10;- Usunięcie starej wersji zmniejsza wykorzystane miejsce&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/frontend/Dockerfile.dev">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/frontend/Dockerfile.dev" />
              <option name="updatedContent" value="# Dockerfile dla środowiska deweloperskiego z hot-reload&#10;&#10;FROM node:22-alpine&#10;&#10;WORKDIR /app&#10;&#10;# Instalacja zależności&#10;COPY package.json package-lock.json* ./&#10;RUN npm ci --prefer-offline --no-audit&#10;&#10;# Kopiowanie plików źródłowych&#10;COPY . .&#10;&#10;# Expose portu&#10;EXPOSE 5173&#10;&#10;# Zmienne środowiskowe dla dev&#10;ENV NODE_ENV=development&#10;&#10;# Uruchomienie w trybie dev z hot-reload&#10;CMD [&quot;npm&quot;, &quot;run&quot;, &quot;dev&quot;, &quot;--&quot;, &quot;--host&quot;, &quot;0.0.0.0&quot;]&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>